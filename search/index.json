[{"content":"链表的概念\r任何数据结构的基础都是创建+增删改查，由这几个操作可以构造很多算法题，所以我们也从这五项开始学习链表。\n什么是单链表\r首先看一下什么是单链表？例如，使用单链表存储 {4，,15，,7，,40}，元素之间像铁链一样相互连接，包含多个节点，每一个节点有一个指向后继原始的next指针。表中最后一个元素指向null，如下图：\n什么是双向链表\r双向链表顾名思义 就是既可以向前，也可以向后。移动元素更方便\n使用链表存储数据，不强制要求数据在内存中集中存储，各个元素可以分散存储在内存中。\n链表的相关概念\r节点和头指针\n节点由两个部分组成：1. 每一个节点的值 2. 指向下一个节点的地址\n头指针：也称头结点，对于单链表而言 如果知道第一个元素，就可以通过遍历访问整个链表\n虚拟节点\n虚拟节点在做题和工程中经常用来处理头结点的问题\n一般写为dummyNode，其next指向head，即dummyNode.next=head\n另外，因为dummyNode的val不会使用，所以一般初始化为0或-1\n创建链表\rJVM 里有栈区和堆区，栈区主要存引用，也就是一个指向实际对象的地址，而堆区存的才是创建的对象，例如我们定义这样一个类：\n1 2 3 4 public class Course{ int val; Course next; } 这时候 next 就指向了下一个同为 Course 类型的对象了，例如： 这里通过栈中的引用（也就是地址）就可以找到 val(1)，然后 val(1)结点又存了指向 val(2)的地址，而 val(3)又存了指向 val(4)的地址，所以就构造出了一个链条访问结构。\nJava 规范的链表定义\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ListNode{ private int data; private ListNode next; public ListNode(int data){ this.data = data; } public int getData() { return data; } public void setData(int data) { this.data = data; } public ListNode getNext() { return next; } public void setNext(ListNode next) { this.next = next; } } LeetCode 中的链表定义\r单链表\r1 2 3 4 5 6 7 8 9 public class ListNode{ private int val; private ListNode next; ListNode(int x){ val=x; next=null; } } ListNode listnode = new ListNode(1); 创建对象后能直接使用 node.val 和 node.next 来操作\n双向链表\r1 2 3 4 5 6 7 8 public class DoublyLinkList { private DoubleNode first; private DoubleNode last; public DoublyLinkList() { first = null; last = first; } DoublyLinkList doublyLinkList = new DoublyLinkList(); 创建对象后能直接使用 node.data node.prev和node.next来操作\n单链表的增删改查\r遍历链表\r对于单链表，不管进行什么操作，一定是从头开始逐个向后访问，所以操作之后是否还能找到表头非常重要。一定要注意避免\u0026quot;狗熊掰棒子\u0026quot;，也就是只顾当前位置而将标记表头的指针丢掉了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static int getListLength(Node head){ int length = 0; Node node = head; //使用局部变量node进行遍历 while(node != null){ length++; node = node.next; } return length; } public static int getListLength(DoubleNode head){ int length = 0; DoubleNode node = head; //使用局部变量node进行遍历 while(node != null){\t//next or prev 都可以 length++; node = node.next; } return length; } 链表插入\r插入操作需要要考虑三种情况：首部、中部和尾部\n在单链表的表头插入 1 2 3 4 5 6 7 8 public static Node insertNodeFromHead(Node head, Node newNode) { if(head==null){ return newNode; } newNode.next = head; head = nodeInsert; return head; } 在单链表中间插入 1 2 3 4 5 6 7 8 9 10 11 12 public static Node insertNodeFromMid(Node head, Node newNode,int position) { if(head==null){ return newNode; } Node pNode = head; for (int i = 1; i \u0026lt; position-1; i++) { //i=1表示从头结点开始 position-1为上一个节点位置 pNode=pNode.next; } newNode.next=pNode.next; pNode.next=newNode; return head; } 在单链表的结尾插入结点 1 2 3 4 5 6 7 8 9 10 11 public static Node insertNodeFromMid(Node head, Node newNode,int position) { if(head==null){ return newNode; } Node pNode = head; for (int i = 1; i \u0026lt; position-1; i++) { //i=1表示从头结点开始 position-1为上一个节点位置 pNode=pNode.next; } pNode.next=newNode; return head; } 链表删除\r删除操作只需要要考虑两种情况：首部、其余位置\n在单链表的表头删除 1 2 3 4 5 6 public static Node delNodeFromHead(Node head) { if(head==null){ return null; } return head.next; } 在单链表的其余位置删除 1 2 3 4 5 6 7 8 9 10 11 public static Node delNodeFromOther(Node head,int position) { if(head==null){ return null; } Node pNode = head; for (int i = 1; i \u0026lt; position-1; i++) { //i=1表示从头结点开始 position-1为pre节点位置 pNode=pNode.next; } pNode.next=pNode.next.next; return head; } 高频面试题\r两个链表的第一个公共子节点\r解法\n哈希和集合\r思路： 将其中一个链表存入集合中，再从头遍历另一个链表。若有相同节点，则第一个交点为第一个公共子节点\n这里集合采用set 是因为set的查询效率比list高是O(1)，另外set只需要存储元素本身，空间开销较小。而map不仅需要存储键值对，还会存储null值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static ListNode findFirstCommonNodeBySet(ListNode headA, ListNode headB) { Set\u0026lt;ListNode\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while (headA != null) { set.add(headA); headA = headA.next; } while (headB != null) { if (set.contains(headB)) return headB; headB = headB.next; } return null; } 栈\r思路： 将两个链表分别压入两个栈中，再同时循环出栈，并记录相同的节点，当至少有其中一个栈遍历结束后，所记录的交点即为第一个公共子节点\n使用栈查找的时间复杂度不如集合快，需要O(m+n)，但重要的是它是一种从后往前查找的逆向思维解法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static ListNode findFirstCommonNodeByStack(ListNode headA, ListNode headB) { Stack\u0026lt;ListNode\u0026gt; stackA = new Stack(); Stack\u0026lt;ListNode\u0026gt; stackB = new Stack(); while (headA != null) { stackA.push(headA); headA = headA.next; } while (headB != null) { stackB.push(headB); headB = headB.next; } ListNode preNode = null; while (stackB.size() \u0026gt; 0 \u0026amp;\u0026amp; stackA.size() \u0026gt; 0) { if (stackA.peek() == stackB.peek()) { preNode = stackA.pop(); stackB.pop(); } else { break; } } return preNode; } 判断链表是否是回文子串\r解法\n递归\r思路： 拷贝当前链表,并通过递归依次对比元素\n栈\r思路： 将链表压入栈，并记录链表长度。 再将链表长度的1/2元素与栈元素依次对比，若有一个不同则不为回文串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static boolean isPalindromeByHalfStack(ListNode head) { if (head == null) { return true; } Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); ListNode temp = head; int count = 0; while (temp != null) { stack.push(temp.val); temp = temp.next; count++; } count \u0026gt;\u0026gt;= 1; //取一半长度 for (int i = 0; i \u0026lt; count; i++) { if (stack.pop() != head.val) { return false; } head = head.next; } return true; } 另一种思路:只压入一半元素到栈中，二者时间复杂度相同 。后者实现起来要更复杂（因为要在一次遍历中确定入栈的位置 所以需要快慢指针）但空间复杂度会比上一种解法要好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public static boolean isPalindromeByHalfStack(ListNode head) { if (head == null) { return true; } Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); ListNode slow = head, fast = head; int count = 0; //当fast指针达到链表尾部时 slow指针指向链表的中间节点 while (fast != null \u0026amp;\u0026amp; fast.next != null) { stack.push(slow.val); slow = slow.next; fast = fast.next.next; } //节点个数为奇数时跳过 if (fast == null) { slow = slow.next; } while (slow != null) { if (stack.pop() != slow.val) { return false; } slow = slow.next; } return true; } 合并两个有序链表\r解法\n思路： 新建一个合并链表 循环遍历2个链表，每次找出最小值加入新建链表，并将较小的链表后移，直到有一个链表遍历完毕 最后若有剩余则添加到新链表中\n代码整合了空值判断，并精简了代码，阅读性可能较差\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode margeHead = new ListNode(-1); while (list1 != null \u0026amp;\u0026amp; list2 != null) { //任意链表遍历完 if (list1.val \u0026lt; list2.val) { margeHead.next = list1; list1 = list1.next; } else if (list1.val \u0026gt; list2.val) { margeHead.next = list2; list2 = list2.next; } else { margeHead.next = list1; margeHead.next.next = list2; list1 = list1.next; list2 = list2.next; } margeHead = margeHead.next; } margeHead.next = (list1 != null) ? list1 : list2;\t//若有剩余则添加到新链表中 return margeHead.next; } 合并多个有序链表\r解法\n思路： 解法与上一题一致 每次合并两个链表 这里写一个demo\n1 2 3 4 5 6 7 public static ListNode mergeKLists(ListNode[] lists) { ListNode res = null; for (ListNode list : lists) { res = mergeTwoLists(res, list); } return res; } 左右边界问题\r本题重点在于开闭区间的判断 ，例如如果是从a到b，那就是闭区间[a,b]。如果是进行分段处理，如K个一组处理，此时就是左闭右开区间，也就是[a,b),此时只需要处理a点，b点则是在下一个区间进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) { ListNode preList1 = list1; //a节点的前驱节点 ListNode postList1 = list1; //b节点 ListNode tailList2 = list2; //list2的尾节点 int count = 0; //找到list1中的a节点的前驱节点和b节点 while (count \u0026lt;= b) { if (count == a - 1) { preList1 = postList1; } postList1 = postList1.next; count++; } //找到list2中的尾节点 while (tailList2.next != null) { tailList2 = tailList2.next; } //拼接链表 preList1.next = list2; tailList2.next = postList1; return list1; } 寻找倒数第k个元素\r1 2 3 4 5 6 7 8 9 10 11 12 13 public static ListNode GetKthFromEnd1(ListNode head, int k) { ListNode fast = head; ListNode slow = head; while (k \u0026gt; 0 \u0026amp;\u0026amp; fast != null) { //避免k大于链表长度 fast = fast.next; k--; } while (fast != null) { fast = fast.next; slow = slow.next; } return slow; } 旋转链表\r解法\n思路： 这道题需要确定旋转的节点位置 即 length-k 所以先计算链表的总长度，再就是关于k的值 若k为length的倍数 相当于移动n周，此时依旧返回head 。其他情况则相当于移动n周后的 length-k 所以只需要考虑 k % length 的余数部即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static ListNode rotateRight(ListNode head, int k) { if (head == null) { return head; } //计算链表总长度 int len = 1; ListNode tail = head; while (tail.next != null) { tail = tail.next; len++; } //处理 k \u0026gt;= length 的情况 k %= len; if (k == 0) { return head; } //寻找到旋转节点的指针 ListNode newTail = head; int count = 1; while (count != len - k) { count++; newTail = newTail.next; } //拼接链表 ListNode newHead = newTail.next; tail.next = head; newTail.next = null; return newHead; } 删除倒数第n个节点\r解法\n计算链表长度\r思路： 先求出链表长度 ，根据length-n 定位删除节点\n防止头结点在操作中丢失 ，先定义一个dummyNode，使其指向head 最后返回dummyNode.next\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static ListNode removeNthFromEndByLength(ListNode head, int n) { if (head == null){ return head; } ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode tailNode = head; int len = 1; while (tailNode.next != null) { tailNode = tailNode.next; len++; } ListNode preNode = dummyNode; int count = 0; while (count \u0026lt; len - n) { preNode = preNode.next; count++; } preNode.next = preNode.next.next; return dummyNode.next; } 解法\n双指针\r慢指针指向dummyNode，防止遍历时head指针丢失 指针赋值时要注意在使用前确保引用的指针没有发生移动，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static ListNode removeNthFromEndByTwoPoints(ListNode head, int n) { ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode fast = head; ListNode slow = dummyNode; while (fast!= null \u0026amp;\u0026amp; n \u0026gt; 0) { fast = fast.next; n--; } while (fast != null) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummyNode.next; } 解法\n栈\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static ListNode removeNthFromEndByStack(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; Deque\u0026lt;ListNode\u0026gt; stack = new LinkedList\u0026lt;ListNode\u0026gt;(); ListNode cur = dummy; while (cur != null) { stack.push(cur); cur = cur.next; } for (int i = 0; i \u0026lt; n; ++i) { stack.pop(); } ListNode prev = stack.peek(); prev.next = prev.next.next; ListNode ans = dummy.next; return ans; } 删除重复节点\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static ListNode deleteDuplicate(ListNode head) { if (head == null) { return head; } ListNode temp = head; while (temp.next != null) { if (temp.val == temp.next.val) { temp.next = temp.next.next; } else { temp = temp.next; } } return head; } 链表是否有环并返回入口\r解法\n哈希\r1 2 3 4 5 6 7 8 9 10 11 public static ListNode detectCycleByMap(ListNode head) { Set\u0026lt;ListNode\u0026gt; seen = new HashSet\u0026lt;ListNode\u0026gt;(); ListNode pos = head; while (pos != null) { if (!seen.add(pos)) { return pos; } pos = pos.next; } return null; } 双指针\r思路： 当快慢指针相遇时，slow 指针已经在环内走了若干步 设链表头到环入口距离为 a，环入口到相遇点距离为 b，环剩余长度为 c 此时 slow 走过的路程为 a + b fast 走过的路程为 a + b + c + b = a + 2b + c 因为 fast 速度是 slow 的两倍，所以有 2(a + b) = a + 2b + c 化简得到 a = c\n当 ptr 走了 a 步到达环入口时，slow 也刚好走了 c 步回到环入口 两者会在环入口处相遇，此时循环结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static ListNode detectCycleByTwoPoint(ListNode head) { if (head == null || head.next == null) { return null; } ListNode fast = head; ListNode slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow){\t//存在环 ListNode ptr = head; while(ptr!=slow){ ptr = ptr.next; slow = slow.next; } return ptr; } } return null; } 双向链表的增删改查\r遍历链表\r1 2 3 4 5 6 7 8 9 public int getListLength(){ int length = 0; DoubleNode current = first\t//从头从尾均可 需要将first 改成 last while (current != null) { length++; current = current.next;\t//从头从尾均可 需要将next 改成 prev } return length; } 链表插入\r头部插入\n1 2 3 4 5 6 7 8 9 10 public void insertFirst(int data) { DoubleNode newDoubleNode = new DoubleNode(data); if (first == null) { last = newDoubleNode; } else { newDoubleNode.next = first; first.prev = newDoubleNode; first = newDoubleNode; //将新结点赋给first（链接）成为第一个结点 } } 尾部插入\n1 2 3 4 5 6 7 8 9 10 public void insertLast(int data) { DoubleNode newDoubleNode = new DoubleNode(data); if (first == null) { last = newDoubleNode; } else { last.next = newDoubleNode; newDoubleNode.prev = last; last = newDoubleNode; //将新结点赋给last（链接）成为新的尾结点 } } 其余位置插入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void insertAfter(int key, int data) { DoubleNode newDoubleNode = new DoubleNode(data); DoubleNode current = first; while ((current != null) \u0026amp;\u0026amp; (current.data != key)) { current = current.next; } //若当前结点current为空 if (current == null) { //current为null有两种情况 一种是链表为空，一种是找不到key值 if (isEmpty()) { //1、链表为空 first = newDoubleNode; //则插入第一个结点（其实可以调用其它的Insert方法） last = newDoubleNode; //first和last均指向该结点（第一个结点） } else { last.next = newDoubleNode; //2、找不到key值 newDoubleNode.prev = last; //则在链表尾部插入一个新的结点 last = newDoubleNode; } } else { if (current == last) { //第三种情况，找到了key值，分两种情况 newDoubleNode.next = null; //1、key值与最后结点的data相等 last = newDoubleNode; //由于newNode将是最后一个结点，则将last指向newNode } else { newDoubleNode.next = current.next; //2、两结点中间插入 四 current.next.prev = newDoubleNode; //将current当前结点的下一个结点赋给newNode.next } //将current下一个结点即current.next的previous域指向current current.next = newDoubleNode; //将当前结点的next域指向newNode newDoubleNode.prev = current; //将新结点的previous域指向current（current在newNode前面一个位置） } } 链表删除\r表头删除\n1 2 3 4 5 6 7 8 9 10 public DoubleNode deleteFirst() { DoubleNode temp = first; if (first.next == null) { //链表中只有一个节点 last = null; } else { first.next.prev = null; first = first.next; }\treturn temp; } 表尾删除\n1 2 3 4 5 6 7 8 9 10 public DoubleNode deleteLast() { DoubleNode temp = last; if (first.next == null) { //链表中只有一个节点 first = null; } else { last.prev.next = null; last=last.prev; }\treturn temp; } 按值删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //按值删除 public DoubleNode deleteKey(int key) { DoubleNode current = first; while (current != null \u0026amp;\u0026amp; current.data != key) { //遍历链表寻找该值所在的结点 current = current.next; } if (current == null) { //若当前结点指向null则返回null， return null; //两种情况当前结点指向null，一是该链表为空链表，而是找不到该值 } else { if (current == first) { //如果current是第一个结点 first = current.next; //则将first指向它，将该结点的previous指向null,其余不变 current.next.prev = null; } else if (current == last) { //如果current是最后一个结点 last = current.prev; //将last指向当前结点的上一个结点（我们将当前结点除名了以后它便不再是最后一个了） current.prev.next = null; //相应的要删除结点的上一个结点的next域应指向null } else { current.prev.next = current.next; //当前结点的上一个结点的next域应指向当前的下一个结点 current.next.prev = current.prev; //当前结点的下一个结点的previous域应指向当前结点的上一个结点 } } return current; //返回 } ","date":"2023-10-16T00:00:00Z","permalink":"/p/%E9%93%BE%E8%A1%A8/","title":"链表"},{"content":"操作系统的基本原理\r操作系统可以看作是人机交互的接口\n进程的状态\r等待态：没有充足资源，没有 CPU 资源\r就绪态：资源充足+缺 CPU\r运行态：资源充足+CPU 资源\r活跃阻塞=等待态 静止阻塞:都缺，但人为挂起 静止就绪: 不缺资源，但人为挂起\nPV 操作\r加入 pv 操作：并发进程操作时加阻塞防止溢出\n死锁\r系统在某个时刻所有的可用的资源都分配出去，所有的进程都等待着其他进程放资源而阻塞，造成死锁\n索引文件结构\r直接索引：4k* 10 1 级间接索引：4k* 1024 2 级间接索引：4k* 10242 3 级间接索引：4k* 10243 间接的级别越高，访问效率越低\n数据传输方式\r是指内存和外设之间的数据传输问题 程序控制方式 最低级也是 CPU 介入最多的方式，外设处于被动，由 CPU 发出查询指令，查询是否传输成功 程序中断方式当完成传输时，会产生中断，提高效率 DMA 方式 直接存取控制，有 DMA 控制器控制外设与内存的数据传输\n微内核\r单体内核 减少系统开销，但系统庞大，占用资源多，系统稳定性差 微内核 内核精炼，便于移植，系统可靠性，安全性和稳定性高，可用于分布式系统，因需要频繁切换内核和用户态，效率相对较低。\n","date":"2023-10-10T00:00:00Z","permalink":"/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统"},{"content":"常用的数据结构\r数组、链表、队、栈、Hash、集合、树、堆。\n常用的算法思想\r查找、排序、双指针、递归、迭代、分治、贪心、回溯和动态规划等等\n","date":"2023-10-10T00:00:00Z","permalink":"/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"常见的数据结构与算法"},{"content":"CPU 结构\rCPU 组成：由运算器、控制器、寄存器组（读取速度最快）、内部总线组成\n运算器组成:\r算数逻辑单元 ALU(Arithmetic logic unit): 实现对数据的算数和逻辑运算\n累加寄存器 AC(Accumulator): 提供数据并暂存运算结果\n数据缓冲寄存器 DR(Data Register): 作为 CPU 和内存、外设之间数据传送的中转站，暂时存放内存的指令或数据\n状态条件寄存器 PSW(Program Status Word): 保存指令运行结果相关的标志位，如中断或进位等标志\n控制器\r指令寄存器 IR （ Instruction Register ） : 暂存当前 CPU 正在执行的指令【操作码和地址码在这里存储】对于用户是透明的\n程序计数器 PC （ Program Counter ）： 用于存放下一条指令的地址\n地址寄存器 AR （ Address Register ）： 保存当前 CPU 所访问的内存地址\n指令译码器 ID （ Instruction Decoder）： 分析指令操作码\n计算机体系结构分类\u0026ndash;Flynn\rSISD 单片机 SIMD 并行，阵列处理（对数组操作）\nMISD 理论模型 MIMD 个人 pc，计算机系统\nCISC 与 RISC\rCISC 计算机不发达时期的产物，指令多，复杂 RISC 现代计算机，指令少，复杂度低，引入了寄存器，效率高\n存储结构\r计算机层次存储结构\r引入cache的原因：存在局部性原理 Cache 和 CPU 交互反交互的时候，暂停和内存的交互，速度就会很快。引入 cache 在提高速度的同时，也没有增加多少成本 局部性原理\r时间局部性:刚刚访问完数据又立即访问，不需要等待。 空间局部性:例如数组的初始化处理，在将数组初始化的过程中，初始化完这一个位置后立即去初始化下一个临近的空间。 工作集原理:工作即是进程，运行时被频繁访问的页面集合。将这些集合打包放进 Cache 里面去，就不需要频繁的替换掉。 主存储器\r主存的分类\r随机存取存储器： DRAM 动态 RAM,SRAM 静态 RAM（断电后无法写入保存数据）\n只读存储器： MROM,PROM,EPROM,flash memory（断电后依然可以写入保存数据）\n磁盘工作原理\r总线系统\r内部总线 通常是指微机内部的，外部芯片与处理器之间的联系，属于是芯片级别的总线 系统总线 属于是微机中各个插件板与系统之间的总线，属于是插件板级别的总线，如 PCI，VGA 数据总线:是用来传输数据的，比如说计算机的 32 位和 64 位，说明了系统总线的宽度就是这么个位数，那么一个周期能够传输的数据是 32164bit。 地址总线:若地址总线的位数是 32 位，那么它代表的地址总线宽度为 2^32，即 4G。因此操作系统是 32 位的，那么他能管理的内存最多是 4g，当然也有硬件有一定关系。 控制总线: 发送相应的控制信号的总线。 外部总线 属于是外部设备的总线。 ","date":"2023-10-10T00:00:00Z","permalink":"/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/","title":"计算机结构"},{"content":"OSI/RM 七层模型\r网络技术标准与协议\rTCP/IP 协议又称重量协议 IPX/SPX 协议（局域网协议） TCP 三次握手协议（可靠，有验证 ） DNS 协议\n递归查询：目标 ip 与域名 1 对 1 迭代查询：目标 ip 与域名的关系，可以是 1 对多 计算机网络分类-拓扑结构\r特殊的 IP 地址\r","date":"2023-10-10T00:00:00Z","permalink":"/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络"},{"content":"数据编码\r若用 1 个字节也就是 8bit 来存放数据 最高位为符号位 0 为正数，1 为负数 原码不能直接运算（eg，1-1） 反码的正数与原码相同，负数符号位不变，其他位置按位取反 补码的正数与反码相同，其他位不变，在反码的末位+1 移码在补码的基础上，把首位取反，（移码中 0 为负数，1 为正数） 以 8bit 为例 原码范围为 -(28-1-1)(28-1-1) 范围：-127127 反码范围为 -(28-1-1)(28-1-1) 范围：-127127 补码范围为 -(28-1-1)(28-1-1) 范围：-128127（补码因进位表示，故多一位） 浮点数运算\r注意使用科学计数法 N = M * Re\n","date":"2023-10-10T00:00:00Z","permalink":"/p/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/","title":"数据的表示"},{"content":"三级模式\r数据库设计过程\rE-R 模型\r实体与关系模式 1 对 1——至少有两种关系模式 1 对 多——职工与部门 多对多——学生与课程\n键\r超键与候选键的区别：超键存在冗余\n范式\r1NF 只包含原子值，每一个分量都是不可再分的数据项 2NF 当且仅当 R 是 1NF,且每一个非主属性完全依赖主键(不存在部分函数依赖) 3NF 当且仅当 R 是 2NF,且 E 中没有非主属性传递依赖于码(不存在部分函数依赖) BCNF E 中每个依赖关系必定包含 E 的某个候选关键字 存在问题：数据冗余，插入异常，删除异常，更新异常\n并发控制\r事务 把操作封装起来，看作一个整体，这些操作同时完成或同时失败。 可能出现的问题：\n丢失更新 不可重复读 读“脏”数据 解决办法\n一级封锁协议：事务 T 在修改数据 R 之前必须先对其加 X 锁，防止丢失修改 二级封锁协议：一级封锁协议加上事务 T 在修改数据 R 之前对其加 S 锁,读完后释放 S 锁，防止读“脏”数据 三级封锁协议：一级封锁协议加上事务 T 在修改数据 R 之前对其加 S 锁,事务结束才释放 S 锁，防止数据重复读 数据库安全\r数据库备份与恢复\r分类方式一\r备份方式 特点 优点 缺点 冷备份(静态备份) 在数据库正常关闭的状态下将数据库的文件全部备份 速度快 不能按表或用户恢复 热备份(动态备份) 在数据库正常运行的状态下将数据库的数据文件备份 可实现恢复某一时间点恢复 不能出错 分类方式二\r完全备份 备份所有数据 差量备份 仅备份上次完全备份后变化的数据 增量备份 备份上传备份后变化的数据\n静态海量转储 系统无运行事务时，转储全部数据库 动态海量转储 系统运行事务时，转储全部数据库 静态增量转储 系统无运行事务时，转储上次更新的数据 动态增量转储 系统运行事务时，转储上次更新的数据 ","date":"2023-10-10T00:00:00Z","permalink":"/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/","title":"数据库系统"},{"content":"记录写博客的第二天\r天气：晴\n心情：开心\n今日歌曲\rhello\nhello\nhello\nhello\n","date":"2023-09-16T13:48:38+08:00","permalink":"/p/%E6%97%A5%E8%AE%B002/","title":"日记02"},{"content":"记录写博客的第三天\r天气：晴\n心情：伤感\n巨人完结了！青春结束了\n今日歌曲\r","date":"2023-09-16T13:48:38+08:00","permalink":"/p/%E6%97%A5%E8%AE%B003/","title":"日记03"},{"content":"数据结构\r什么是数据结构\r数据结构:是相互之间存在的一种或多种特定关系的数据元素的集合\n逻辑结构与物理结构\r按照视点的不同 把数据结构分为逻辑结构和物理结构。\n逻辑结构\r数据对象中数据元素之间的相互关系\n集合结构中的元素同属于同一个集合，之间没有任何关系，各个数据元素是“平等的”\n线性结构中的数据元素是一对一的关系\n树形结构中的数据元素存在一对多的层次关系\n图形结构的数据元素是多对多的关系\n物理结构\r逻辑结构在计算机的存储形式\n顺序存储结构 数据元素存放在地址相同的存储单元 数据间逻辑关系和物理关系一致 链式存储结构 数据元素存放在任意的存储单元 存储单元可以是连续也可以不连续 时间复杂度\r时间复杂度的时间指的是用语句的执行次数，而不是实际的时间。我们知道计算机执行乘除运算是非常消耗资源的，而加减则计算很快，时间复杂度只是一个简化的描述。\n常见的阶耗费时间的关系是: 时间复杂度练习\r设 n 为正整数，试确定下列各程序段中前置以记号@的语句的频度\n第一题\n1 2 3 4 5 6 7 8 x=91; y=100; while(y\u0026gt;0) { @ if(x\u0026gt;100) { x -= 10; y--; } else x++; 第二题\n1 2 3 4 5 6 7 i=1; j=0; while(i+j\u0026lt;=n) { @ if(i\u0026gt;j) j++; else i++; } 第三题\n1 2 3 4 x=n; y=0; while(x\u0026gt;=(y+1)*(y+1)) { @ y++; } 第四题\n1 2 3 4 5 k=0; for(i=1; i\u0026lt;=n; i++) { for(j=i; j\u0026lt;=n; j++) @ k++; } 第五题\n1 2 3 4 5 for(i=1; i\u0026lt;=n; i++) { for(j=1; j\u0026lt;=i; j++) { for(k=1; k\u0026lt;=j; k++) @ x += delta; } 答案：\n$$ 1100$$ $$n$$ $$\\sqrt{n}$$ $$\\frac{n(n+1)}{2}$$ $$\\frac{n(n+1)(n+2)}{6}$$ ","date":"2023-09-14T00:00:00Z","permalink":"/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"数据结构与时间复杂度"},{"content":" Object 类的主要方法\nNO. 方法名称 类型 描述 1 public Object{} 构造 构造方法 2 public boolean equal（Object obj） 普通 对象比较 3 public int hashcode（） 普通 取得 hash 值 4 public String toString（） 普通 对象在打印时调用地址 ","date":"2022-09-18T00:00:00Z","permalink":"/p/object%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95/","title":"Object类的主要方法"},{"content":" java 的四种访问权限修饰符\n修饰符 类内部 同一个包 子类 同一个包 private Yes default Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes ","date":"2022-09-18T00:00:00Z","permalink":"/p/%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/","title":"四种访问权限修饰符"},{"content":"基本概念\r常用命令\rgit分支规范\r分支类型 说明 主分支（master） 存放正式发布的代码 开发分支（dev） 存放最新的开发代码 功能分支（feature） 每个新功能或修复都在一个独立的分支上进行开发 热修复分支（hotfix） 用于修复生产环境中的紧急问题 发布分支（release） 用于准备发布的代码，从dev分支创建，发布后合并到master和dev分支 测试分支（test） 用于功能测试，从feature分支创建，测试通过后合并到dev分支 预发布分支（pre-release） 用于测试新功能或修复，从dev分支创建，测试通过后合并到release分支 预发布测试分支（pre-release-test） 用于预发布测试，从pre-release分支创建，测试通过后合并到release分支 git提交规范\r类型前缀 用途 eg feat 新增功能（feature） feat: 添加用户登录功能 fix 修复 bug fix: 修复登录页面的 bug docs 仅文档修改（如 README、注释） docs: 更新 API 文档 style 仅格式调整（不影响代码逻辑，如空格、缩进、换行） style: 调整代码缩进 refactor 代码重构（既不新增功能，也不修复 bug） refactor: 优化数据库查询 test 新增 / 修改测试代码 test: 添加单元测试 chore 构建流程、工具配置、依赖管理等杂项修改 chore: 更新依赖版本 misc 其他改变 misc: 调整代码结构 ","date":"2022-09-10T00:00:00Z","image":"/p/git%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E8%A7%84%E8%8C%83/01_hu_628837ed7b462ab0.png","permalink":"/p/git%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E8%A7%84%E8%8C%83/","title":"git的注意事项与规范"},{"content":" java.lang java 语言的核心类 如 String Math Integer\njava.net 网络操作的类和接口\njava.io 输入输出类\nava.util 实用工具类，定义系统特性，接口集合框架\njava.text java 格式化相关类\njava.sql java 进行 JDBC 相关类，接口\njava.swt 抽象窗口工具集类 GUI\njava.applet applet 运行类\n","date":"2022-09-10T00:00:00Z","permalink":"/p/jdk%E4%B8%AD%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8C%85%E4%BB%8B%E7%BB%8D/","title":"JDK中主要的包介绍"},{"content":"常用快捷键\rCtrl\n快捷键 介绍 Ctrl+D 复制当前行 Ctrl+X 删除当前行 Ctrl+W 递进式选中代码（从光标处向外扩展） Ctrl+O 重写方法 Ctrl+F7 高亮当前方法中的所选内容 Ctrl+F8 设置断点 Ctrl+F9 重新编译当前文件 Shift\n快捷键 介绍 shift+F6 快速更改 shift+F10 Run shift+F9 Debug shift+F11 弹出书签显示层 shift+Tab 取消缩进 Ctrl+Alt\n快捷键 介绍 ctrl+Alt+L 格式化代码 ctrl+Alt+v 引入变量 ctrl+Alt+t Surround With 快捷键 ctrl+Alt+O 优化导入的类，可以对当前文件和整个包目录使用 ctrl+Alt+S 打开 IDEA 系统设置 ctrl+Alt+Enter 光标所在行上空出一行，光标定位到新行 ctrl+Alt+←/→ 退回/前进到上一个操作的地方 Ctrl+Shift\n快捷键 介绍 Ctrl+Shift+U 对选中的代码进行大 / 小写轮流转换 Ctrl+Shift+w 递进式选中代码（从光标处向内扩展） Ctrl+Shift+↑/↓ 移动当前行或代码块 Fn\n快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 F3 跳转到下一个匹配项(gitlog中的diff跳转到下一个diff) F4 跳转到当前方法的调用位置(直接进入gitlog中的文件) F5 copy F6 remove F7 调试时步入（进入方法内部） F8 调试时步过（不进入方法内部） F9 调试时继续执行到下一个断点 JetBrains 系列软件的常见图标\r图标地址 https://intellij-icons.jetbrains.design/\n插件推荐\r插件名称 介绍 GitToolBox 方便操作 Git 仓库 Rainbow Brackets Lite 免费开源的彩虹括号 Translate 翻译插件 Key promoter X 显示当前操作的快捷键 AI assistant 因为插件类型还是以QA为主，所以随便选一家的即可 我一直用的是阿里的 LingMa Nyan Progress Bar 彩虹猫进度条 ","date":"2022-09-10T00:00:00Z","image":"/p/jetbrains%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/02_hu_8ef93643d9908650.png","permalink":"/p/jetbrains%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","title":"JetBrains系列软件的使用心得"},{"content":" java 类及类的成员 面向对象的三大特征 其他关键字\n","date":"2022-09-10T00:00:00Z","permalink":"/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象"},{"content":" 一维数组 多维数组\n","date":"2022-09-10T00:00:00Z","permalink":"/p/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":" 算数运算符 逻辑运算符 位运算符\n","date":"2022-09-10T00:00:00Z","permalink":"/p/%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"运算符"},{"content":" 算数运算符 逻辑运算符 位运算符\n","date":"2022-09-10T00:00:00Z","permalink":"/p/%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"运算符"}]